head	1.12;
access;
symbols;
locks; strict;
comment	@# @;


1.12
date	2003.09.12.17.45.55;	author marco;	state Exp;
branches;
next	1.11;

1.11
date	2003.08.18.11.16.48;	author marco;	state Exp;
branches;
next	1.10;

1.10
date	2002.12.26.11.28.14;	author marco;	state Exp;
branches;
next	1.9;

1.9
date	2002.10.26.13.44.51;	author marco;	state Exp;
branches;
next	1.8;

1.8
date	2002.08.05.07.24.00;	author marco;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.08.12.29.27;	author marco;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.08.12.28.30;	author marco;	state Exp;
branches;
next	1.5;

1.5
date	2002.04.29.14.55.04;	author marco;	state Exp;
branches;
next	1.4;

1.4
date	2002.04.29.14.52.55;	author marco;	state Exp;
branches;
next	1.3;

1.3
date	2002.04.27.08.18.24;	author marco;	state Exp;
branches;
next	1.2;

1.2
date	2002.04.27.08.03.41;	author marco;	state Exp;
branches;
next	1.1;

1.1
date	2002.04.27.07.55.28;	author marco;	state Exp;
branches;
next	;


desc
@@


1.12
log
@*** empty log message ***
@
text
@\input texinfo.tex
@@c $Id: alist.texi,v 1.11 2003/08/18 11:16:48 marco Exp marco $
@@c %**start of header
@@setfilename alist.info
@@settitle Alist
@@c %**end of header

@@syncodeindex tp cp
@@syncodeindex fn cp

@@include version.texi

@@c ------------------------------------------------------------

@@ifinfo
@@macro tclcmd{NAME}
[\NAME\]
@@end macro
@@end ifinfo

@@ifnotinfo
@@macro tclcmd{NAME}
@@code{[\NAME\]}
@@end macro
@@end ifnotinfo


@@macro tclvar{NAME}
@@code{\NAME\}
@@end macro

@@macro tclcode{CODE}
@@code{[\CODE\]}
@@end macro


@@c ------------------------------------------------------------
@@titlepage
@@title Alist
@@subtitle Version @@version{}
@@author Marco Maggi
@@page
@@vskip 0pt plus 1filll
@@noindent
This document is copyright @@copyright{} 2002, 2003 by Marco Maggi. 

Permission is granted to make and distribute verbatim copies of this
document provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
document under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.
@@ignore

Permission is granted to process this file through TeX and print the
results, provided the printed document carries a copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).

@@end ignore
@@end titlepage


@@c ------------------------------------------------------------
@@ifinfo
@@dircategory Development
@@direntry
* Alist: (alist).               Treat lists as key/value pairs sequences. 
@@end direntry
@@end ifinfo


@@c ------------------------------------------------------------
@@ifnottex
@@node Top
@@top Alist @@version{}

@@noindent
@@emph{Alist} is a C language extension library for TCL.  It provides
additional commands to a TCL interpreter.

This package implements a set of experimental commands to access a list
of elements as key/value pairs. All the commands are created in the
@@code{alist} namespace.

     
@@menu
* Copying::                     Copying this document. 
* Overview::                    Overview of the library. 
* Format::                      What's an alist and what's his format. 
* TCL API::                     The TCL commands.
* C API::                       The C language functions.
* Concept Index::               An entry for each concept. 
@@end menu
@@end ifnottex


@@c ------------------------------------------------------------
@@node Copying
@@chapter Copying this document

@@noindent
This document is copyright @@copyright{} 2002, 2003 by Marco Maggi.

Permission is granted to make and distribute verbatim copies of this
document provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
document under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.


@@c ------------------------------------------------------------
@@node Overview
@@chapter Overview of the library

@@noindent
This file documents @@emph{Alist} @@version{}.  This package adds some
commands to a Tcl interpreter.

The purpose of this library is to provide an experimental package to do
some test, particularly on the packaging infrastructure (@@acronym{TEA}).

The concept of this library is to test the feasibility/utility of
treating a list as a sequence of key/value pairs.  That is: access a
list as an associative array. This is obviously slow for big lists, but
can be used to store little data structures with a fixed set of keys.

This addresses two ``problems'': arrays consumes a lot of memory, it's
boring to configure an array to raise an error if we try to set an
invalid key.


@@c ------------------------------------------------------------
@@node Format
@@chapter What's an alist and what's his format


@@noindent
An ``alist'' (association list) is a collection of key/value pairs; it
can be treated as a linear implementation of an associative array. The
layout of an alist is as follows:

@@example
@@{ KEY1 VALUE1 KEY2 VALUE2 ... @@}
@@end example

Values are set and extracted selecting the corresponding key. An alist
data portion as an even number of elements; but if the number of
elements is odd, the last is treated as a list of properties and ignored
by non--property related commands.

At present the property list handling is not implemented yet.


@@c ------------------------------------------------------------
@@node TCL API
@@chapter The @@acronym{TCL} commands


@@noindent
By default the single command @@tclcmd{alist} is added to the global
namespace; but, if the @@code{--enable-namespace} option is used with the
@@command{configure} script at compile time, all the subcommands are
created in the @@code{::alist} namespace.

@@menu
* Set and get::                 Setting and getting values. 
* Inspection::                  Inspecting an alist.
* Misc::                        Miscellaneous commands.
@@end menu


@@c ------------------------------------------------------------
@@node Set and get
@@section Setting and getting values


@@deffn Command assign @@var{alist} @@var{key} @@var{value}
@@deffnx Command {alist assign} @@var{alist} @@var{key} @@var{value}
Sets a new element for the value associated with a key in an alist.
This command treats @@var{alist} as a sequence of key/value pairs.  The
value associated with @@var{key} is replaced with @@var{value}. Returns
the new list.
@@end deffn


@@deffn Command at @@var{alist} @@var{key}
@@deffnx Command {alist at} @@var{alist} @@var{key}
Returns the value associated with a key in an alist.  This command
treats @@var{alist} as a sequence of key/value pairs. It looks for the
@@var{key} element and returns the element next to it.
@@end deffn



@@c ------------------------------------------------------------
@@node Inspection
@@section Inspecting an alist

@@noindent
The following commands are declared in the @@code{alist} namespace.


@@deffn Command names @@var{alist}
@@deffnx Command {alist } @@var{alist}
Gets the list of keys in an alist.  This command treats @@var{alist} as a
sequence of key/value pairs.  Returns the set of keys, that is: all the
elements located at even positions.  If @@var{alist} has an odd number of
elements, the last is ignored.
@@end deffn


@@deffn Command values @@var{alist}
@@deffnx Command {alist values} @@var{alist}
Gets the list of values in an alist. This command treats @@var{alist} as
a sequence of key/value pairs.  Returns the set of values, that is all
the elements located at odd positions.  If @@var{alist} has an odd number
of elements, the last is ignored.
@@end deffn


@@c ------------------------------------------------------------
@@node Misc
@@section Miscellaneous commands


@@deffn Command version
@@deffnx Command {alist version}
Returns the version number of the library.
@@end deffn


@@c ------------------------------------------------------------
@@node C API
@@chapter The C language functions



@@deftypefun int AList_ObjAssign (@@var{interp}, @@var{alistPre}, @@var{key}, @@var{value}, @@var{alistPost})
Sets a new value for the element associated with a key.

Arguments:

@@table @@code
@@item Tcl_Interp *@@var{interp}
interp used to report errors;

@@item Tcl_Obj *@@var{alistPre}
ptr to the list of objects;

@@item Tcl_Obj *@@var{key}
ptr to the key object;

@@item Tcl_Obj *@@var{value}
ptr to the new value;

@@item Tcl_Obj ** @@var{alistPost}
ptr to a target variable that will hold the new alist;
@@end table

Returns @@code{TCL_OK} or @@code{TCL_ERROR}.  If shared the alist is
duplicated; the object referenced by @@var{alistPost} has @@code{refCount}
equal to that of @@code{*@@var{alistPre}} or equal to zero.
@@end deftypefun


@@deftypefun int AList_Assign (@@var{interp}, @@var{alistPre}, @@var{key}, @@var{value}, @@var{alistPost})
Like @@code{AList_ObjAssign()}, but @@var{key} is a @@code{CONST char *}.
@@end deftypefun


@@deftypefun int AList_ObjAt (@@var{interp}, @@var{alist}, @@var{key}, @@var{value})
Extracts the value associated to a given key.

Arguments:

@@table @@code
@@item Tcl_Interp *@@var{interp}
interp used to report errors;

@@item Tcl_Obj *@@var{alist}
pointer to the alist object;

@@item Tcl_Obj *@@var{key}
pointer to the key object;

@@item Tcl_Obj **@@var{value}
ptr to a target variable.
@@end table

Returns @@code{TCL_OK} or @@code{TCL_ERROR} if the key is not present.
The result object has reference counter untouched.
@@end deftypefun


@@deftypefun int AList_At (@@var{interp}, @@var{alist}, @@var{key}, @@var{value})
Like @@code{AList_ObjAt()}, but @@var{key} is a @@code{CONST char *}.
@@end deftypefun


@@deftypefun int AList_GetNames (@@var{interp}, @@var{alist}, @@var{namesPtr})
Extracts all the key objects from an alist.

Arguments:

@@table @@code
@@item Tcl_Interp *@@var{interp}
interp used to report errors;

@@item Tcl_Obj *@@var{alist}
ptr to the alist object;
@@item Tcl_Obj **@@var{namesPtr}
ptr to a target variable that will hold the result.
@@end table

Returns @@code{TCL_OK} or @@code{TCL_ERROR}.The result object has
@@code{refCount} left to zero.
@@end deftypefun


@@deftypefun int AList_GetValues (@@var{interp}, @@var{alist}, @@var{valuesPtr})
Extracts all the values in the alist, that is: a list holding elements
number 1, 3, 5, @@dots{}

Arguments:

@@table @@code
@@item Tcl_Interp *@@var{interp}
interp used to report errors;

@@item Tcl_Obj *@@var{alist}
ptr to the alist;

@@item Tcl_Obj **@@var{valuesPtr}
ptr to a target variable that will hold the result.
@@end table

Returns @@code{TCL_OK} or @@code{TCL_ERROR}. The result object has
@@code{refCount} left to zero.
@@end deftypefun


@@c ------------------------------------------------------------
@@node Concept Index
@@appendix An entry for each concept
     
@@printindex cp

@@contents
@@bye

@@c end of file
@@c Local Variables:
@@c mode: texinfo
@@c page-delimiter: "^@@c -+$"
@@c End:
@


1.11
log
@*** empty log message ***
@
text
@d2 1
a2 1
@@c $Id: alist.texi,v 1.10 2002/12/26 11:28:14 marco Exp marco $
d11 1
a11 1
@@include version.inc
@


1.10
log
@*** empty log message ***
@
text
@d2 1
a2 1
@@c $Id: alist.texi,v 1.9 2002/10/26 13:44:51 marco Exp marco $
d13 2
d45 1
a45 1
This document is copyright @@copyright{} 2002 by Marco Maggi. 
d81 2
a82 2
@@emph{Alist} is a C language extension library for Tcl.  It provides
additional commands to a Tcl interpreter.
a100 1
@@ifnottex
d105 1
a105 1
This document is copyright @@copyright{} 2002 by Marco Maggi.
a114 1
@@end ifnottex
a344 13
@@end deftypefun


@@deftypefun CONST char ** AList_MakeKeyVector (Tcl_Obj **@@var{objs}, int @@var{length})
Build a @@code{NULL}--terminated array of string pointers to be used with
@@code{Tcl_GetIndexFromObj()}, the strings are the keys of the alist. If
the alist has an odd number of elements, the last element is ignored.

Arguments: @@var{objs} the array of alist objects; @@var{length} the
number of objects in @@var{objs}.

Returns a pointer to a vector of strings.  It's responsibility of the
caller to free the vector with @@code{Tcl_Free()}.
@


1.9
log
@*** empty log message ***
@
text
@d2 1
a2 1
@@c $Id: alist.texi,v 1.8 2002/08/05 07:24:00 marco Exp marco $
d8 2
d45 2
a46 2
Permission is  granted to  make and distribute  verbatim copies  of this
document provided  the copyright notice  and this permission  notice are
d49 3
a51 3
Permission is granted to  copy and distribute  modified versions of this
document under the  conditions  for verbatim copying, provided  that the
entire resulting   derived  work is distributed under    the terms of  a
a52 5

Permission  is  granted to  copy  and  distribute  translations of  this
document into another language,  under the above conditions for modified
versions,  except  that  this  permission  notice  may  be  included  in
translations approved by Marco Maggi instead of in the original English.
d55 3
a57 3
Permission is  granted to  process this file  through TeX and  print the
results,  provided the  printed  document carries  a copying  permission
notice identical  to this one except  for the removal  of this paragraph
d89 1
a89 1
* Overview::                    Overview of this document. 
d91 2
a92 2
* Set and get::                 Setting and getting values. 
* Inspection::                  Inspecting an alist.
a93 1
* Function Index::              An entry for each procedure. 
a113 5

Permission is granted to copy and distribute translations of this
document into another language, under the above conditions for modified
versions, except that this permission notice may be included in
translations approved by Marco Maggi instead of in the original English.
d119 1
a119 1
@@chapter Overview of this document
d161 18
d180 1
a180 1
@@chapter Setting and getting values
a181 2
@@noindent
The following commands are declared in the @@code{alist} namespace.
d184 1
a184 1

d193 1
a193 1

d203 1
a203 1
@@chapter Inspecting an alist
d210 1
a210 1

a214 1

d219 1
a219 1

d224 2
d227 8
d238 122
a366 5
@@node Function Index
@@appendix An entry for each function
     
@@printindex fn
     
@


1.8
log
@*** empty log message ***
@
text
@d2 1
a2 1
@@c $Id: alist.texi,v 1.7 2002/05/08 12:29:27 marco Exp marco $
d82 2
a83 2
@@emph{Alist} is a C  language extension library for Tcl.  It
provides additional commands to a Tcl interpreter.
d85 3
a87 3
This package  implements a  set of experimental  commands to
access  a  list of  elements  as  key/value  pairs. All  the
commands are created in the @@code{alist} namespace.
d108 10
a117 1
This document is copyright @@copyright{} 2002 by Marco Maggi. 
d119 4
a122 15
Permission is granted to make and distribute verbatim copies
of  this document  provided  the copyright  notice and  this
permission notice are preserved on all copies.

Permission  is  granted  to  copy  and  distribute  modified
versions of this document  under the conditions for verbatim
copying, provided that the  entire resulting derived work is
distributed under the terms of a permission notice identical
to this one.

Permission is granted to copy and distribute translations of
this  document  into   another  language,  under  the  above
conditions   for  modified   versions,   except  that   this
permission notice  may be included  in translations approved
by Marco Maggi instead of in the original English.
d131 14
a144 19
This file documents @@emph{Alist} @@version{}.  The package is
released  under  the  @@acronym{GNU}  Lesser  General  Public
License (@@acronym{LGPL}).

This package adds some commands to a Tcl interpreter.

The purpose  of this library  is to provide  an experimental
package  to  do some  test,  particularly  on the  packaging
infrastructure (TEA).

The   concept    of   this   library   is    to   test   the
feasibility/utility  of treating  a  list as  a sequence  of
key/value pairs.  That is: access  a list as  an associative
array. This is obviously slow for big lists, but can be used
to store little data structures with a fixed set of keys.

This addresses  two ``problems'':  arrays consumes a  lot of
memory, it's boring to configure  an array to raise an error
if we try to set an invalid key.
d153 3
a155 3
An ``alist'' (association list) is a collection of key/value
pairs; it  can be treated  as a linear implementation  of an
associative array. The layout of an alist is as follows:
d161 4
a164 5
Values  are set  and extracted  selecting  the corresponding
key. An  alist data portion  as an even number  of elements;
but if the number of elements is odd, the last is treated as
a list  of properties  and ignored by  non--property related
commands. 
d166 1
a166 2
At  present the  property list  handling is  not implemented
yet.
d174 1
a174 2
The  following  commands are  declared  in the  @@code{alist}
namespace.
d178 4
a181 4
Sets a new element for the value associated with a key in an
alist.   This command  treats @@var{alist}  as a  sequence of
key/value  pairs.  The  value associated  with  @@var{key} is
replaced with @@var{value}. Returns the new list.
d187 3
a189 4
Returns the value  associated with a key in  an alist.  This
command  treats  @@var{alist}  as  a  sequence  of  key/value
pairs. It  looks for the  @@var{key} element and  returns the
element next to it.
d204 4
a207 5
Gets  the list  of keys  in an  alist.  This  command treats
@@var{alist} as  a sequence of key/value  pairs.  Returns the
set  of keys,  that is:  all  the elements  located at  even
positions.  If  @@var{alist} has  an odd number  of elements,
the last is ignored.
d214 4
a217 5
Gets the  list of  values in an  alist. This  command treats
@@var{alist} as  a sequence  of key/value pairs.  Returns the
set  of values,  that is  all  the elements  located at  odd
positions.  If  @@var{alist} has  an odd number  of elements,
the last is ignored.
@


1.7
log
@*** empty log message ***
@
text
@d2 1
a2 1
@@c $Id: alist.texi,v 1.6 2002/05/08 12:28:30 marco Exp marco $
d82 2
a83 2
@@emph{Alist} is  a C language  extension library for Tcl.  It provides
additional commands to a Tcl interpreter.
d85 3
a87 3
This package implements a set  of experimental commands to access a list
of  elements as key/value  pairs. All  the commands  are created  in the
@@code{alist} namespace. 
d110 15
a124 13
Permission is  granted to  make and distribute  verbatim copies  of this
document provided  the copyright notice  and this permission  notice are
preserved on all copies.

Permission is granted to  copy and distribute  modified versions of this
document under the  conditions  for verbatim copying, provided  that the
entire resulting   derived  work is distributed under    the terms of  a
permission notice identical to this one.

Permission  is  granted to  copy  and  distribute  translations of  this
document into another language,  under the above conditions for modified
versions,  except  that  this  permission  notice  may  be  included  in
translations approved by Marco Maggi instead of in the original English.
d133 19
a151 2
This file  documents @@emph{Alist} @@version{}.  The  package is released
under the @@acronym{GNU} Lesser General Public License (@@acronym{LGPL}). 
a152 1
This package adds some commands to a Tcl interpreter. 
d154 3
a156 2
The purpose of this library is  to provide an experimental package to do
some test, particularly on the packaging infrastructure (TEA).
a157 8
The  concept of  this  library  is to  test  the feasibility/utility  of
treating a list as a sequence of key/value pairs. That is: access a list
as an associative  array. This is obviously slow for  big lists, but can
be used to store little data structures with a fixed set of keys.

This addresses two  ``problems'': arrays consumes a lot  of memory, it's
boring to  configure an  array to  raise an error  if we  try to  set an
invalid key.
d159 14
d174 2
a175 3
@@c ------------------------------------------------------------
@@node Format
@@chapter What's an alist and what's his format
d183 2
a184 1
The following commands are declared in the @@code{alist} namespace.
d188 4
a191 4
Set a new element for the value associated with a key in an alist.  This
command treats @@var{alist}  as a sequence of key/value  pairs. It search
the @@var{key} element  and replace with @@var{value} the  element next to
it. Returns the new list.
d197 4
a200 3
Returns  the value  associated with  a key  in an  alist.   This command
treats @@var{alist}  as a sequence of  key/value pairs. It  looks for the
@@var{key} element and returns the element next to it.
d215 5
a219 4
Get the list  of keys in an alist. This command  treats @@var{alist} as a
sequence of  key/value pairs. Returns the  set of keys, that  is all the
elements located at even positions.  If @@var{alist} has an odd number of
elements, the last is ignored.
d226 5
a230 4
Get the list of values in an alist. This command treats @@var{alist} as a
sequence of key/value pairs. Returns the  set of values, that is all the
elements located at odd positions.   If @@var{alist} has an odd number of
elements, the last is ignored.
d253 1
a253 1
@@c page-separator: "^@@c -+$"
@


1.6
log
@*** empty log message ***
@
text
@d2 1
a2 1
@@c $Id: alist.texi,v 1.5 2002/04/29 14:55:04 marco Exp marco $
d186 1
d193 11
@


1.5
log
@*** empty log message ***
@
text
@d2 1
a2 1
@@c $Id: alist.texi,v 1.4 2002/04/29 14:52:55 marco Exp marco $
d26 4
@


1.4
log
@*** empty log message ***
@
text
@d2 1
a2 1
@@c $Id: alist.texi.in,v 1.3 2002/04/27 08:18:24 marco Exp marco $
d32 1
a32 1
@@subtitle Version @@VERSION@@
d75 1
a75 1
@@top Alist @@VERSION@@
d127 1
a127 1
This file  documents @@emph{Alist} @@VERSION@@.  The  package is released
@


1.3
log
@*** empty log message ***
@
text
@d2 1
a2 1
@@c $Id: alist.texi.in,v 1.2 2002/04/27 08:03:41 marco Exp marco $
d9 2
d154 2
d179 2
@


1.2
log
@*** empty log message ***
@
text
@d2 1
a2 1
@@c $Id: alist.texi.in,v 1.1 2002/04/27 07:55:28 marco Exp marco $
a82 12
The purpose of this library is  to provide an experimental package to do
some test, particularly on the packaging infrastructure (TEA).

The  concept of  this  library  is to  test  the feasibility/utility  of
treating a list as a sequence of key/value pairs. That is: access a list
as an associative  array. This is obviously slow for  big lists, but can
be used to store little data structures with a fixed set of keys.

This addresses two  ``problems'': arrays consumes a lot  of memory, it's
boring to  configure an  array to  raise an error  if we  try to  set an
invalid key.

d89 1
d130 11
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
@@c $Id: moretcl.texi.in,v 1.5 2002/04/27 06:55:04 marco Exp $
d4 2
a5 2
@@setfilename moretcl.info
@@settitle MoreTcl
d29 1
a29 1
@@title MoreTcl
d65 1
a65 1
* MoreTcl: (moretcl).           Additional commands for Tcl. 
d73 1
a73 1
@@top MoreTcl @@VERSION@@
d76 1
a76 1
@@emph{MoreTcl} is  a C language  extension library for Tcl.  It provides
d79 16
d99 2
a100 2
* Loops::                       Additional loop statements. 
* Exceptions::                  Managing exceptions and error codes. 
d136 1
a136 1
This file  documents @@emph{MoreTcl} @@VERSION@@.  The  package is released
d144 2
a145 2
@@node Loops
@@chapter Additional loop statements
d148 3
a150 1
@@cindex Loop statements
d153 1
a153 2
@@noindent
The following commands are declared in the @@code{more} namespace.
d155 5
a160 1
@@deffn Command do @@var{body} while @@var{expr}
d162 1
a162 4
Evaluates  @@var{body} in  the scope  of the  caller while  @@var{expr} is
true. Honors  the @@tclcmd{break}, @@tclcmd{continue},  @@tclcmd{error} and
@@tclcmd{return} exceptions.  @@var{body} is evaluated at least once.  The
return value is the result of the last command in @@var{body}.
d164 3
a166 5
@@example
do @@{
   # do something
@@} while @@{ #condition @@}
@@end example
a169 20
@@deffn Command loop @@var{integer} ?@@var{varName}? @@var{body}

Evaluates  @@var{body} in the  scope of  the caller  @@var{integer} times.
Honors   the  @@tclcmd{break},   @@tclcmd{continue},   @@tclcmd{error}  and
@@tclcmd{return} exceptions.  If @@var{varName}  is given, a variable with
such name is  created and set to 0 before  the evaluation of @@var{body},
and incremented by 1 at each  evaluation. The return value is the result
of  the last  command in  @@var{body}.  This is  a little  faster than  a
@@tclcmd{for} loop.

@@example
loop 10 @@{
   # repeat this 10 times
@@}

loop 10 i @@{
   # repeat this 10 times and use $i as a counter
@@}
@@end example
@@end deffn
d172 2
a173 23
@@node Exceptions
@@chapter Managing exceptions and error codes

@@cindex Exception handling


@@noindent
The following commands are declared in the @@code{more} namespace.


@@deffn Command try @@var{body} ?finally @@var{script}? ?catch @@var{list}? 

Eval @@var{body}.  After that if @@var{script} is present, it's evaluated.
The  command return  an empty  string unless  in body  a @@tclcmd{return}
command is evaluated:  in that case the return value  is the argument of
the @@tclcmd{return}.  @@var{list} is a list of string patterns/scripts:

@@example
    PATTERN SCRIPT
    PATTERN SCRIPT
    PATTERN SCRIPT
    ... 
@@end example
a174 5
@@noindent
the patterns are the ones accepted by the @@code{[string match]} command.

If an error is raised in @@var{body}, the values of @@tclvar{::errorCode}
and  @@tclvar{::errorInfo} are  saved; then  @@var{script}  is evaluated.
d176 1
a176 39
After  that,  the  original  value of  @@tclvar{::errorCode}  is  checked
against each  of the  patterns in @@var{list}.   At the first  match the
corresponding script  is evaluated. Before  the evaluation of  the catch
script:  a local  variable @@tclvar{orgErrCode}  is set  to  the original
@@tclvar{::errorCode} value; a  local variable @@tclvar{orgErrInfo} is set
to the original @@tclvar{::errorInfo} value.

If   none   of   the   patterns   match,  the   command   returns   with
@@tclvar{::errorCode} and @@tclvar{::erroInfo} set to the original values.

Rules follows. 

@@itemize @@bullet

@@item
If @@tclcmd{break},  @@tclcmd{continue} or @@tclcmd{return}  are invoked in
the   finally    @@var{script};   an   error   string    is   stored   in
@@tclvar{::errorInfo};   @@tclvar{::errorCode}  is   set   to  @@code{LOGIC
INVALID_ARGUMENT}     the     command     returns     with     condition
@@code{TCL_ERROR}. The catch list is ignored even if an error occurred in
the @@var{body}.

@@item
If an  error occurs  in the finally  @@var{script}, the  command returns
with  condition @@code{TCL_ERROR}. The  value of  @@tclvar{::errorCode} is
left unchanged to what the finally @@var{script} has set. 

@@item
If    an    error   occurs    setting    the   @@tclvar{orgErrCode}    or
@@tclvar{orgErrInfo}   variables,   an   error   string  is   stored   in
@@tclvar{::errorInfo}  and  @@tclvar{::errorCode}  is set  to  @@code{LOGIC
INVALID_ARGUMENT}. The command returns with condition @@code{TCL_ERROR}.

@@item
If an error occurs in a  catch arm, the value of @@tclvar{::errorCode} is
checked:  if it's  @@code{RETRY_PLEASE} (yes)  the command  is reexecuted
with  the  same arguments.   Else  the  command  returns with  condition
@@code{TCL_ERROR}, the value of @@tclvar{::errorCode} is left unchanged to
what the catch script has set.
d178 4
a181 1
@@end itemize
a182 90


@@deffn Command retry

Set   @@tclvar{::errorCode}  to   @@code{RETRY_PLEASE}  and   return  with
condition @@code{TCL_ERROR}.
@@end deffn


@@subsection Examples

@@noindent
Throw an error and catch it in the @@code{*ONE*} arm. 

@@example
try @@{
    error "bad thing" @@{@@} CODEONE
@@} catch @@{
    *ONE* @@{ ... @@}
    *TWO* @@{ ... @@}
@@}
@@end example


Throw  an error,  print  @@code{here} to  stdout,  then catch  it in  the
@@code{*ONE*} arm.

@@example
try @@{
    error "bad thing" @@{@@} CODEONE
@@} finally @@{
    puts here
@@} catch @@{
    *ONE* @@{ ... @@}
    *TWO* @@{ ... @@}
@@}
@@end example


Throw an error that is not catched.

@@example
try @@{
    error "bad thing" @@{@@} CODEFOUR
@@} catch @@{
    *ONE* @@{ #... @@}
    *TWO* @@{ #... @@}
@@}
@@end example

Throw an error,  catch it in the @@code{*TWO*} arm and  retry. This is an
infinite loop.

@@example
try @@{
    error "bad thing" @@{@@} CODETWO
@@} catch @@{
    *ONE* @@{ #... @@}
    *TWO* @@{ retry @@}
@@}
@@end example

Ask the user  before overwriting a file.  If  the user agrees overwrite,
else rethrow the error.

@@example
set filename "turquoise"
set access @@{CREAT EXCL WRONLY@@}

try @@{
    set id [open $filename $access]
    puts $id 456
    close $id
@@} catch @@{
    @@{POSIX EEXIST*@@} @@{
        puts -nonewline stderr \
            [format "%s exists, overwrite? " $filename]
        gets stdin answer
        if @@{[string compare $answer yes] == 0@@} @@{
            set access @@{CREAT WRONLY TRUNC@@}
            retry
        @@} else @@{
            error [format "I refuse to overwrite file (%s)" \
                $filename] @@{@@} $orgErrCode
        @@}
    @@}
@@}
@@end example


@
