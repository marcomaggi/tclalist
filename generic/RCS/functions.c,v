head	1.6;
access;
symbols;
locks; strict;
comment	@ * @;


1.6
date	2003.09.12.17.47.19;	author marco;	state Exp;
branches;
next	1.5;

1.5
date	2003.08.18.10.53.54;	author marco;	state Exp;
branches;
next	1.4;

1.4
date	2003.08.18.10.34.42;	author marco;	state Exp;
branches;
next	1.3;

1.3
date	2002.10.26.13.47.07;	author marco;	state Exp;
branches;
next	1.2;

1.2
date	2002.05.06.15.56.41;	author marco;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.06.15.31.05;	author marco;	state Exp;
branches;
next	;


desc
@@


1.6
log
@*** empty log message ***
@
text
@/* functions.c --
   
   Part of: AList
   Contents: alist functions
   Date: Mon May  6, 2002
   
   Abstract
   
   
   
   Copyright (c) 2002, 2003 Marco Maggi
   
   The author hereby grant  permission to use, copy, modify, distribute,
   and  license this  software and  its documentation  for  any purpose,
   provided that  existing copyright notices are retained  in all copies
   and that  this notice is  included verbatim in any  distributions. No
   written agreement, license, or royalty fee is required for any of the
   authorized uses.   Modifications to this software  may be copyrighted
   by their  authors and need  not follow the licensing  terms described
   here, provided that the new  terms are clearly indicated on the first
   page of each file where they apply.
   
   IN NO EVENT  SHALL THE AUTHOR OR DISTRIBUTORS BE  LIABLE TO ANY PARTY
   FOR DIRECT,  INDIRECT, SPECIAL, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES
   ARISING OUT  OF THE USE OF  THIS SOFTWARE, ITS  DOCUMENTATION, OR ANY
   DERIVATIVES  THEREOF, EVEN  IF THE  AUTHOR HAVE  BEEN ADVISED  OF THE
   POSSIBILITY OF SUCH DAMAGE.
   
   THE  AUTHOR AND  DISTRIBUTORS SPECIFICALLY  DISCLAIM  ANY WARRANTIES,
   INCLUDING,   BUT  NOT   LIMITED   TO,  THE   IMPLIED  WARRANTIES   OF
   MERCHANTABILITY,    FITNESS   FOR    A   PARTICULAR    PURPOSE,   AND
   NON-INFRINGEMENT.  THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, AND
   THE   AUTHOR  AND   DISTRIBUTORS  HAVE   NO  OBLIGATION   TO  PROVIDE
   MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
   
   $Id: functions.c,v 1.5 2003/08/18 10:53:54 marco Exp marco $
*/


/** ------------------------------------------------------------
 ** Header files.
 ** ----------------------------------------------------------*/

#include "alistInt.h"



/** ------------------------------------------------------------
 ** Prototypes.
 ** ----------------------------------------------------------*/

static CONST char **	Alist_MakeKeyVector _ANSI_ARGS_((Tcl_Obj **objs,
							 int length));




/* Alist_ObjAssign --

	Sets a new value for the element associated with a key.

   Arguments:

	interp -	if not NULL, the interpreter in which
			report errors
	alistPre -	pointer to the source alist
	keyObj -	pointer to an object holding the key
	valueObj -	pointer to an object holding the value
	alistPost -	pointer to a variable that will hold the
			modified alist

   Results:

        Returns TCL_OK or TCL_ERROR.

   Side effects:

        If  shared the  alist is  duplicated, the  object  referenced by
        alistPost has  refCount equal to  that of *alistPre or  equal to
        zero.

*/

int
Alist_ObjAssign (interp, alistPre, keyObj, valueObj, alistPost)
     Tcl_Interp *	interp;
     Tcl_Obj *		alistPre;
     Tcl_Obj *		keyObj;
     Tcl_Obj *		valueObj;
     Tcl_Obj **		alistPost;
{
  int		e, i, alistLen;
  Tcl_Obj *	alistObj;
  Tcl_Obj **	alistObjVector;
  CONST char **	keys;  


  alistObj = alistPre;
  if (Tcl_IsShared(alistObj))
    {
      alistObj = Tcl_DuplicateObj(alistObj);
    }

  e = Tcl_ListObjGetElements(interp, alistObj, &alistLen, &alistObjVector);
  if (e != TCL_OK)
    {
      if (interp != NULL)
	{
	  Tcl_SetErrorCode(interp, ALIST_ERRCODE_INVALID_ARGUMENT, NULL);
	}
      goto Error;
    }

  keys = Alist_MakeKeyVector(alistObjVector, alistLen);
  e = Tcl_GetIndexFromObj(interp, keyObj, keys, "key", 0, &i);
  ckfree((char *) keys);
  if (e != TCL_OK)
    {
      if (interp != NULL)
	{
	  Tcl_SetErrorCode(interp, ALIST_ERRCODE_INVALID_ARGUMENT, NULL);
	}
      goto Error;
    }


  /*
    Store the element.
  */

  i *= 2;
  if (i == alistLen)
    {
      if (interp != NULL)
	{
	  Tcl_SetErrorCode(interp, ALIST_ERRCODE_INVALID_ARGUMENT, NULL);
	  Tcl_SetResult(interp, "too few elements in list", TCL_STATIC);
	}
      goto Error;
    }

  e = Tcl_ListObjReplace(interp, alistObj, i+1, 1, 1, &valueObj);
  if (e != TCL_OK)
    {
      Tcl_SetErrorCode(interp, ALIST_ERRCODE_INVALID_ARGUMENT, NULL);
      goto Error;
    }

  /*
    The result is the new list.
  */

  *alistPost = alistObj;
  return TCL_OK;

 Error:
  Tcl_IncrRefCount(alistObj);
  Tcl_DecrRefCount(alistObj);
  return TCL_ERROR;
}



/* Alist_Assign --

	Sets a new value for the element associated with a key.

   Arguments:

	interp -	if not NULL, the interpreter in which
			report errors
	alistPre -	pointer to the list of objects
	key -		pointer to the string holding the key
	value -		pointer to the object holding the new value
	alistPost -	pointer to a target variable that will hold
			the new alist

   Results:

        Returns TCL_OK or TCL_ERROR.

   Side effects:

        If  shared the  alist is  duplicated, the  object  referenced by
        alistPost has  refCount equal to  that of *alistPre or  equal to
        zero.

*/

int
Alist_Assign (interp, alistPre, key, valueObj, alistPost)
     Tcl_Interp *	interp;
     Tcl_Obj *		alistPre;
     CONST char *	key;
     Tcl_Obj *		valueObj;
     Tcl_Obj **		alistPost;
{
  int		e;
  Tcl_Obj *	keyObj;


  keyObj = Tcl_NewStringObj(key, -1);
  Tcl_IncrRefCount(keyObj);
  e = Alist_ObjAssign(interp, alistPre, keyObj, valueObj, alistPost);
  Tcl_DecrRefCount(keyObj);
  return e;
}



/* Alist_ObjAt --

	Extracts the value associated to a given key.

   Arguments:

	interp -	if not NULL, the interpreter used to
			report errors
	alistObj -	pointer to the alist object
	keyObj -	pointer to the key object
	valueObjPtr -	pointer to the target variable that will hold
			the selecte object's pointer

   Results:

        Returns TCL_OK or TCL_ERROR if the key is not present.

   Side effects:

        The result object has reference counter untouched.

*/

int
Alist_ObjAt (interp, alistObj, keyObj, valueObjPtr)
     Tcl_Interp	*	interp;
     Tcl_Obj *		alistObj;
     Tcl_Obj *		keyObj;
     Tcl_Obj **		valueObjPtr;
{
  int		e, i, alistLen;
  Tcl_Obj **	alistObjVector;
  CONST char **	keys;  


  e = Tcl_ListObjGetElements(interp, alistObj, &alistLen, &alistObjVector);
  if (e != TCL_OK)
    {
      if (interp != NULL)
	{
	  Tcl_SetErrorCode(interp, ALIST_ERRCODE_INVALID_ARGUMENT, NULL);
	}
      return e;
    }

  keys = Alist_MakeKeyVector(alistObjVector, alistLen);

  e = Tcl_GetIndexFromObj(interp, keyObj, keys, "key", 0, &i);
  Tcl_Free((char *) keys);
  if (e != TCL_OK)
    {
      if (interp != NULL)
	{
	  Tcl_SetErrorCode(interp, ALIST_ERRCODE_INVALID_ARGUMENT, NULL);
	}
      return e;
    }

  *valueObjPtr = alistObjVector[2*i+1];
  return TCL_OK;
}



/* Alist_At --

	Extracts the value associated to a given key.

   Arguments:

	interp -	if not NULL, the interpreter in which
			report errors
	alistObj -	pointer to the list of objects
	key -		pointer to the key string
	valueObjPtr -	pointer to the target variable that will hold
			the selecte object's pointer

   Results:

        Returns TCL_OK or TCL_ERROR.

   Side effects:

        If  shared the  alist is  duplicated, the  object  referenced by
        alistPost has  refCount equal to  that of *alistPre or  equal to
        zero.

*/

int
Alist_At (interp, alistObj, key, valueObjPtr)
     Tcl_Interp *	interp;
     Tcl_Obj *		alistObj;
     CONST char *CONST	key;
     Tcl_Obj **		valueObjPtr;
{
  int		e;
  Tcl_Obj *	keyObj;


  keyObj = Tcl_NewStringObj(key, -1);
  Tcl_IncrRefCount(keyObj);
  e = Alist_ObjAt(interp, alistObj, keyObj, valueObjPtr);
  Tcl_DecrRefCount(keyObj);
  return e;
}



/* Alist_GetNames --

	Extracts all the key objects from an alist.

   Arguments:

	interp -	if not NULL, the interp used to report errors
	alistObj -	poitner to the alist object
	namesObjPtr -	pointer to a target variable that will hold
			the result

   Results:

        Returns TCL_OK or TCL_ERROR.

   Side effects:

        The result object has refCount left to zero.

*/

int
Alist_GetNames (interp, alistObj, namesObjPtr)
     Tcl_Interp *	interp;
     Tcl_Obj *		alistObj;
     Tcl_Obj **		namesObjPtr;
{
  int		e, i, alistLen;
  Tcl_Obj *	namesObj;
  Tcl_Obj **	alistObjVector;


  e = Tcl_ListObjGetElements(interp, alistObj, &alistLen, &alistObjVector);
  if (e != TCL_OK)
    {
      if (interp != NULL)
	{
	  Tcl_SetErrorCode(interp, ALIST_ERRCODE_INVALID_ARGUMENT, NULL);
	}
      return e;
    }

  namesObj = Tcl_NewListObj(0, 0);
  
  if (alistLen % 2)
    {
      --alistLen;
    }

  for (i=0; i<alistLen; i+=2)
    {
      e = Tcl_ListObjAppendElement(interp, namesObj, alistObjVector[i]);
      if (e != TCL_OK)
	{
	  if (interp != NULL)
	    {
	      Tcl_SetErrorCode(interp, ALIST_ERRCODE_INTERNAL_ERROR, NULL);
	    }
	  goto Error;
	}
    }

  *namesObjPtr = namesObj;
  return TCL_OK;

 Error:
  Tcl_IncrRefCount(namesObj);
  Tcl_DecrRefCount(namesObj);
  return TCL_ERROR;
}




/* Alist_GetValues --

   	Extracts all  the values in the  alist, that is:  a list holding
   	elements number 1, 3, 5, ...

   Arguments:

	interp -	if not NULL, the interpreter used to
			report errors
	alistObj -	pointer to the alist object
	valuesObjPtr -	pointer to a target variable that will hold
			the result

   Results:

        Returns TCL_OK or TCL_ERROR.

   Side effects:

        The result object has refCount left to zero.

*/

int
Alist_GetValues (interp, alistObj, valuesObjPtr)
     Tcl_Interp *	interp;
     Tcl_Obj *		alistObj;
     Tcl_Obj **		valuesObjPtr;
{
  int		e, i, alistLen;
  Tcl_Obj *	valuesObj;
  Tcl_Obj **	alistObjVector;


  e = Tcl_ListObjGetElements(interp, alistObj, &alistLen, &alistObjVector);
  if (e != TCL_OK)
    {
      if (interp != NULL)
	{
	  Tcl_SetErrorCode(interp, ALIST_ERRCODE_INVALID_ARGUMENT, NULL);
	}
      return e;
    }

  valuesObj = Tcl_NewListObj(0, 0);
  
  if (alistLen % 2)
    {
      --alistLen;
    }

  for (i=1; i<alistLen; i+=2)
    {
      e = Tcl_ListObjAppendElement(interp, valuesObj, alistObjVector[i]);
      if (e != TCL_OK)
	{
	  if (interp != NULL)
	    {
	      Tcl_SetErrorCode(interp, ALIST_ERRCODE_INTERNAL_ERROR, NULL);
	    }
	  goto Error;
	}
    }

  *valuesObjPtr = valuesObj;
  return TCL_OK;

 Error:
  Tcl_IncrRefCount(valuesObj);
  Tcl_DecrRefCount(valuesObj);
  return TCL_ERROR;
}




/* Alist_MakeKeyVector --

	Builds  a NULL-terminated array  of string  pointers to  be used
	with  Tcl_GetIndexFromObj(), the  strings  are the  keys of  the
	alist.  If the alist  has an  odd number  of elements,  the last
	element is ignored.

   Arguments:

	objs -		the array of alist objects
	length -	the number of objects in "objs"

   Results:

        Returns a pointer to a vector of strings.

   Side effects:

        It's  responsibility  of the  caller  to  free  the vector  with
        Tcl_Free().

*/

static CONST char **
Alist_MakeKeyVector (Tcl_Obj **objs, int length)
{
  int i, knum;
  CONST char **keys;
  

  knum = length/2;
  keys = (CONST char **) ckalloc(sizeof(char *) * (knum+1));
  for (i=0; i<knum; ++i)
    {
      keys[i] = Tcl_GetString(objs[i*2]);
    }
  keys[knum] = NULL;

  return keys;
}


/* end of file */
@


1.5
log
@*** empty log message ***
@
text
@d36 1
a36 1
   $Id: functions.c,v 1.4 2003/08/18 10:34:42 marco Exp marco $
d92 1
a92 1
  int		e, i, alistLen, knum;
d241 1
a241 1
  int		e, i, alistLen, knum;
a349 1
  char **	keys;
a425 1
  char **	keys;
@


1.4
log
@*** empty log message ***
@
text
@d36 1
a36 1
   $Id: functions.c,v 1.3 2002/10/26 13:47:07 marco Exp marco $
d52 1
a52 1
static CONST char **	AList_MakeKeyVector _ANSI_ARGS_((Tcl_Obj **objs,
d58 1
a58 1
/* AList_ObjAssign --
d85 1
a85 1
AList_ObjAssign (interp, alistPre, keyObj, valueObj, alistPost)
d114 1
a114 1
  keys = AList_MakeKeyVector(alistObjVector, alistLen);
d164 1
a164 1
/* AList_Assign --
d191 1
a191 1
AList_Assign (interp, alistPre, key, valueObj, alistPost)
d204 1
a204 1
  e = AList_ObjAssign(interp, alistPre, keyObj, valueObj, alistPost);
d211 1
a211 1
/* AList_ObjAt --
d235 1
a235 1
AList_ObjAt (interp, alistObj, keyObj, valueObjPtr)
d256 1
a256 1
  keys = AList_MakeKeyVector(alistObjVector, alistLen);
d275 1
a275 1
/* AList_At --
d301 1
a301 1
AList_At (interp, alistObj, key, valueObjPtr)
d313 1
a313 1
  e = AList_ObjAt(interp, alistObj, keyObj, valueObjPtr);
d320 1
a320 1
/* AList_GetNames --
d342 1
a342 1
AList_GetNames (interp, alistObj, namesObjPtr)
d395 1
a395 1
/* AList_GetValues --
d419 1
a419 1
AList_GetValues (interp, alistObj, valuesObjPtr)
d472 1
a472 1
/* AList_MakeKeyVector --
d496 1
a496 1
AList_MakeKeyVector (Tcl_Obj **objs, int length)
@


1.3
log
@*** empty log message ***
@
text
@d11 1
a11 2
   Copyright (c) 2002 Marco Maggi
   email: <marcomaggi at tiscalinet dot it>
d36 1
a36 1
   $Id: functions.c,v 1.2 2002/05/06 15:56:41 marco Exp marco $
d39 4
d47 9
d60 1
a60 1
	Set a new value for the element associated with a key.
d64 7
a70 5
	interp: interp used to report errors
	alistPre: ptr to the list of objects
	key: ptr to the key object
	value: ptr to the new value
	alistPost: ptr to a target variable that will hold the new alist
d85 6
a90 6
AList_ObjAssign (interp, alistPre, key, value, alistPost)
     Tcl_Interp		*interp;
     Tcl_Obj		*alistPre;
     Tcl_Obj		*key;
     Tcl_Obj		*value;
     Tcl_Obj		**alistPost;
d92 4
a95 4
  int e, i, length, knum;
  Tcl_Obj *alist;
  Tcl_Obj **obs;
  CONST char **keys;  
d98 2
a99 4
  /* the refCount is left untouched  here, we will incr and decr only in
     case of error */
  alist = alistPre;
  if (Tcl_IsShared(alist))
d101 1
a101 1
      alist = Tcl_DuplicateObj(alist);
d104 1
a104 1
  e = Tcl_ListObjGetElements(interp, alist, &length, &obs);
d107 4
a110 1
      Tcl_SetErrorCode(interp, ALIST_ERRCODE_INVALID_ARGUMENT, NULL);
d114 3
a116 3
  keys = AList_MakeKeyVector(obs, length);
  e = Tcl_GetIndexFromObj(interp, key, keys, "key", 0, &i);
  Tcl_Free((char *) keys);
d119 4
a122 1
      Tcl_SetErrorCode(interp, ALIST_ERRCODE_INVALID_ARGUMENT, NULL);
d128 2
a129 2
   * Store the element.
   */
d132 1
a132 1
  if (i == length)
d134 5
a138 2
      Tcl_SetErrorCode(interp, ALIST_ERRCODE_INVALID_ARGUMENT, NULL);
      Tcl_SetResult(interp, "too few elements in list", TCL_STATIC);
d142 1
a142 1
  e = Tcl_ListObjReplace(interp, alist, i+1, 1, 1, &value);
d150 2
a151 2
   * The result is the new list.
   */
d153 1
a153 1
  *alistPost = alist;
d157 2
a158 2
  Tcl_IncrRefCount(alist);
  Tcl_DecrRefCount(alist);
d166 1
a166 1
	Set a new value for the element associated with a key.
d170 7
a176 5
	interp: interp used to report errors
	alistPre: ptr to the list of objects
	key: ptr to the key string
	value: ptr to the new value
	alistPost: ptr to a target variable that will hold the new alist
d191 6
a196 6
AList_Assign (interp, alistPre, key, value, alistPost)
     Tcl_Interp		*interp;
     Tcl_Obj		*alistPre;
     CONST char 	*key;
     Tcl_Obj		*value;
     Tcl_Obj		**alistPost;
d198 2
a199 2
  int e;
  Tcl_Obj *keyObj;
d204 1
a204 1
  e = AList_ObjAssign(interp, alistPre, keyObj, value, alistPost);
d213 1
a213 1
	Extract the value associated to a given key.
d217 6
a222 4
	interp: interp used to report errors
	alist: pointer to the alist object
	key: pointer to the key object
	value: ptr to a target variable
d235 5
a239 5
AList_ObjAt (interp, alist, key, value)
     Tcl_Interp	*interp;
     Tcl_Obj	*alist;
     Tcl_Obj	*key;
     Tcl_Obj	**value;
d241 3
a243 3
  int e, i, length, knum;
  Tcl_Obj **obs;
  CONST char **keys;  
d246 1
a246 1
  e = Tcl_ListObjGetElements(interp, alist, &length, &obs);
d249 4
a252 1
      Tcl_SetErrorCode(interp, ALIST_ERRCODE_INVALID_ARGUMENT, NULL);
d256 1
a256 1
  keys = AList_MakeKeyVector(obs, length);
d258 1
a258 1
  e = Tcl_GetIndexFromObj(interp, key, keys, "key", 0, &i);
d262 4
a265 1
      Tcl_SetErrorCode(interp, ALIST_ERRCODE_INVALID_ARGUMENT, NULL);
d269 1
a269 1
  *value = obs[2*i+1];
d277 1
a277 1
	Set a new value for the element associated with a key.
d281 6
a286 5
	interp: interp used to report errors
	alistPre: ptr to the list of objects
	key: ptr to the key string
	value: ptr to the new value
	alistPost: ptr to a target variable that will hold the new alist
d301 3
a303 3
AList_At (interp, alist, key, value)
     Tcl_Interp		*interp;
     Tcl_Obj		*alist;
d305 1
a305 1
     Tcl_Obj		**value;
d307 2
a308 2
  int e;
  Tcl_Obj *keyObj;
d313 1
a313 1
  e = AList_ObjAt(interp, alist, keyObj, value);
d322 1
a322 1
	Extract all the key objects from an alist.
d326 4
a329 3
	interp: interp used to report errors
	alist: ptr to the alist object
	namesPtr: ptr to a target variable that will hold the result
d342 4
a345 4
AList_GetNames (interp, alist, namesPtr)
     Tcl_Interp		*interp;
     Tcl_Obj		*alist;
     Tcl_Obj		**namesPtr;
d347 4
a350 4
  int e, i, length;
  Tcl_Obj *names;
  Tcl_Obj **obs;
  char **keys;
d353 1
a353 1
  e = Tcl_ListObjGetElements(interp, alist, &length, &obs);
d356 4
a359 1
      Tcl_SetErrorCode(interp, ALIST_ERRCODE_INVALID_ARGUMENT, NULL);
d363 1
a363 1
  names = Tcl_NewListObj(0, 0);
d365 1
a365 1
  if (length % 2)
d367 1
a367 1
      --length;
d370 1
a370 1
  for (i=0; i<length; i+=2)
d372 1
a372 1
      e = Tcl_ListObjAppendElement(interp, names, obs[i]);
d375 4
a378 1
	  Tcl_SetErrorCode(interp, ALIST_ERRCODE_INTERNAL_ERROR, NULL);
d383 1
a383 1
  *namesPtr = names;
d387 3
a389 3
  Tcl_IncrRefCount(names);
  Tcl_DecrRefCount(names);
  return TCL_OK;
d397 1
a397 1
   	Extract all  the values  in the alist,  that is: a  list holding
d402 5
a406 3
	interp: interp used to report errors
	alist: ptr to the alist
	valuesPtr: ptr to a target variable that will hold the result
d419 4
a422 4
AList_GetValues (interp, alist, valuesPtr)
     Tcl_Interp		*interp;
     Tcl_Obj		*alist;
     Tcl_Obj		**valuesPtr;
d424 4
a427 4
  int e, i, length;
  Tcl_Obj *values;
  Tcl_Obj **obs;
  char **keys;
d430 1
a430 1
  e = Tcl_ListObjGetElements(interp, alist, &length, &obs);
d433 4
a436 1
      Tcl_SetErrorCode(interp, ALIST_ERRCODE_INVALID_ARGUMENT, NULL);
d440 1
a440 1
  values = Tcl_NewListObj(0, 0);
d442 1
a442 1
  if (length % 2)
d444 1
a444 1
      --length;
d447 1
a447 1
  for (i=1; i<length; i+=2)
d449 1
a449 1
      e = Tcl_ListObjAppendElement(interp, values, obs[i]);
d452 4
a455 1
	  Tcl_SetErrorCode(interp, ALIST_ERRCODE_INTERNAL_ERROR, NULL);
d460 1
a460 1
  *valuesPtr = values;
d464 2
a465 2
  Tcl_IncrRefCount(values);
  Tcl_DecrRefCount(values);
d474 4
a477 4
	Build a NULL-terminated array of string pointers to be used with
	Tcl_GetIndexFromObj(), the strings are the keys of the alist. If
	the alist  has an  odd number of  elements, the last  element is
	ignored.
d481 2
a482 2
	objs: the array of alist objects
	length: the number of objects in "objs"
d495 1
a495 1
CONST char **
d503 1
a503 1
  keys = (CONST char **) Tcl_Alloc(sizeof(char *) * (knum+1));
@


1.2
log
@*** empty log message ***
@
text
@d14 9
a22 4
   This library is free software;  you can redistribute it and/or modify
   it  under the  terms  of the  GNU  Lesser General  Public License  as
   published by the Free Software  Foundation; either version 2.1 of the
   License, or (at your option) any later version.
d24 5
a28 4
   This library is  distributed in the hope that it  will be useful, but
   WITHOUT  ANY   WARRANTY;  without   even  the  implied   warranty  of
   MERCHANTABILITY  or FITNESS FOR  A PARTICULAR  PURPOSE.  See  the GNU
   Lesser General Public License for more details.
d30 6
a35 4
   You  should have received  a copy  of the  GNU Lesser  General Public
   License along with  this library; if not, write  to the Free Software
   Foundation, Inc.,  59 Temple Place, Suite 330,  Boston, MA 02111-1307
   USA
d37 1
a37 1
   $Id: functions.c,v 1.1 2002/05/06 15:31:05 marco Exp marco $
@


1.1
log
@Initial revision
@
text
@d29 1
a29 1
   $Id$
d38 1
a38 1
/* AList_Assign --
d46 1
a46 1
	key: ptr to the key string
d63 1
a63 1
AList_Assign (interp, alistPre, key, value, alistPost)
d66 1
a66 1
     CONST char *CONST	key;
d73 1
a73 1
  char **keys;  
d130 46
a175 1
  return TCL_OK;
d180 1
a180 1
/* AList_At --
d188 1
a188 1
	key: pointer to the key string
d202 5
a206 5
AList_At (interp, key, value)
     Tcl_Interp		*interp;
     Tcl_Obj		*alist;
     CONST char *CONST	key;
     Tcl_Obj **value;
d210 1
a210 1
  char **keys;  
d236 44
d375 1
d411 1
a411 2
  return TCL_OK;
  return TCL_OK;
d440 1
a440 1
char **
d443 2
d448 1
a448 1
  keys = (char **) Tcl_Alloc(sizeof(char *) * (knum+1));
d451 1
a451 1
      keys[i] = Tcl_GetString(obs[i*2]);
d454 3
@
